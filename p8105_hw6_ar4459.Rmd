---
title: "p8105_hw6_ar4459_practice"
author: "ASHLEY ROMO"
date: "2023-11-30"
output: html_document
---

load key packages
```{r}
library(tidyverse)
library(p8105.datasets)
library(modelr)

set.seed(1)
knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

### Problem 2
```{r}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2022-01-01",
    date_max = "2022-12-31") |>
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) |>
  select(name, id, everything())
```

First, I created a bootstrap function. 
```{r}
# bootstrap function 
boot_sample = function(df) {
  
  sample_frac(df, replace = TRUE)
}
```

Next, I apply the bootsrap function and use broom::glance to calculate the r square value.
```{r}
# apply bootstrap for r square
boot_results_r =
  tibble(strap_number = 1:50) |> 
  mutate(
    strap_sample = map(strap_number, \(i) boot_sample(weather_df)),
    models = map(strap_sample, \(df) lm(tmax ~ tmin + prcp, data = df)),
    results = map(models, broom::glance))|> 
  select(-strap_sample, -models) |> 
    unnest(results) |> 
   janitor::clean_names() 
  
#r.square plot
boot_results_r |> 
  ggplot(aes(x = r_squared)) +
  geom_density() +
  labs(
    x = "R Squared",
    y = "Density",
    title = "Distribution of R Squared"
  )

```
The r square plot is unimodal. The max r squared is `r max(boot_results_r |> pull(r_squared))`.


Now, I apply the bootstrap function to the dataframe and use the broom::tidy function to calculate the beta estimates. I use pivot_wider to isolate the values for tmin and prcp and also rename tmin to beta1 and prcp to beta2. 
```{r}
# apply bootstrap for log(b1*b2)
boot_results_beta =
  tibble(strap_number = 1:50) |> 
  mutate(
    strap_sample = map(strap_number, \(i) boot_sample(weather_df)),
    models = map(strap_sample, \(df) lm(tmax ~ tmin + prcp, data = df)),
    results = map(models, broom::tidy))|> 
    unnest(results) |> 
  janitor::clean_names() |> 
  select(strap_number, term, estimate) |> 
  pivot_wider(
    names_from = term,
    values_from = estimate) |> 
  rename(
    beta1 = tmin,
    beta2 = prcp) |> 
  mutate(
    log_betas = log(beta1*beta2)
  ) |> 
  drop_na()

#plot for log betas
boot_results_beta |> 
  ggplot(aes(x = log_betas)) +
  geom_density() +
  labs(
    x = "log(beta1*beta2)",
    y = "density",
    title = "Distribution of log of beta1*beta2")
```


Now, I calculate the 95% confidence interval for the log(beta1*beta2) and the r squared.
```{r}
#95% confidence interval for r square
boot_results_r |> 
#group_by() -- in class he used group_by -- do I need to use it, too?
  summarize(
    ci_lower_est = quantile(r_squared, 0.025),
    ci_upper_est = quantile(r_squared, 0.0975)) |> 
  knitr::kable(digits = 2)

#95% confidence interval for log(beta1*beta2)
boot_results_beta |> 
#  group_by(term) -- in class he used group_by -- do I need to use it, too?
  summarize(
    ci_lower_est = quantile(log_betas, 0.025),
    ci_upper_est = quantile(log_betas, 0.0975)) |> #is this 0.025 or 0.95 for upper estimate of CI
  knitr::kable(digits = 2)
```


### Problem 3

```{r}
#data cleaning
bw_data = 
  read_csv("data/birthweight.csv") |> 
  drop_na()
  
#propose a linear regression model
# add another predictor (stepwise?)
linear_mod = lm(bwt ~ . , data = bw_data) 

#applyimg the stepwise function
stepwise = step(linear_mod, direction = "both")

#adding predictions (how do I plot it against fitted)
bw_data  |> 
  modelr::add_predictions(linear_mod) |> 
  ggplot(aes(x = delwt, y = bwt)) + 
  geom_point() + 
  geom_line(aes(y = pred))

#adding residuals (how do I plot it against fitted)
bw_data |> 
  modelr::add_residuals(linear_mod) |> 
  ggplot(aes(x = delwt, y = bwt)) + 
  geom_point() + 
  geom_line(aes(y = resid))
```

Compare model to two other ones
```{r}
#model 1
model_one = lm(bwt ~ blength + gaweeks, data = bw_data)

#model 2
model_two = lm(bwt ~ bhead + blength + babysex + bhead*blength + bhead*babysex + blength*babysex + bhead*blength*babysex, data = bw_data)
```

Cross Validation 
```{r}
cv_df = 
  bw_data |> 
  crossv_mc(n = 100) |> 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  )

#how do I choose the x and ys for the model???
cv_results =
  cv_df 
#|> 
#  mutate(
#    linear_mod = map(train, \(df) lm(bwt ~ x, data = df)),
#    model_one = map(train, \(df) lm(bwt ~ x, data = df)),
#    model_twot = map(train, \(df) lm(bwt ~ x, data = df))
#  ) |> 
#  mutate(
#    rmse_linear = map2_dbl(linear_mod, test, \(mod, df) rmse(mod, df)),
#    rmse_model_one = map2_dbl(model_one, test, \(mod, df) rmse(mod, df)),
#    rmse_model_two = map2_dbl(model_two, test, \(mod, df) rmse(mod, df))
#  )
```

